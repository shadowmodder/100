Maximum Number in Mountain Sequence
Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.

Example
Given nums = [1, 2, 4, 8, 6, 3] return 8
Given nums = [10, 9, 8, 7], return 10

// this is to find the peak, assume there is no duplicated number;

int findPeak(int[] nums) {
    if (nums == null || nums.length == 0) return -1;
    if (nums.length == 1) return 0;
    if (nums[0] > nums[1]) return 0;
    if (nums[nums.lenght-1] > nums[nums.length-2]) return nums.length-1;
    int begin = 0;
    int end = nums.length - 1;
    
    while (begin < end) {
        int mid = begin + (end - begin)/2;
        if ((nums[mid] > nums[mid-1]) && (nums[mid] > nums[mid+1) {
            return mid;
        } else if (nums[mid] > nums[mid-1]) {
            begin = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    
    return -1;
}

int findPeak(int[] nums) {
    if (nums == null || nums.length == 0) return -1;
    
    int begin = 0;
    int end = nums.length-1;
    while (begin < end) {
        int mid = begin + (end-begin)/2;
        if (nums[mid] < nums[mid+1]) {
            start = mid+1;
        } else {
            // use 'mid' as Approximation condition, don't need to consider the '=='
            end = mid;
        }
    }
    return begin;
}

int findPeak(int[] nums) {
    if (nums == null || nums.length == 0) return -1;
    
    int begin = 0;
    int end = nums.length-1;
    
    while (begin + 1 < end) {
        int mid = begin + (end-begin+1)/2;
        
        if (nums[mid] > nums[mid-1) {
            begin = mid;
        } else {
            end = mid;
        }
    }
    
    return Math.max(nums[begin], nums[end]);
}
